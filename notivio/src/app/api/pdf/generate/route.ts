import { NextResponse } from "next/server";
import PDFDocument from "pdfkit";

// Enable streaming response (recommended for PDF responses in Next.js)
export async function POST(request: Request) {
  try {
    const { notes } = await request.json();

    if (!notes) {
      return NextResponse.json({ error: "Notes data is required" }, { status: 400 });
    }

    const doc = new PDFDocument({ margin: 50 });
    const chunks: Buffer[] = [];

    // ✅ Ensure chunk is typed correctly
    doc.on("data", (chunk: Buffer) => chunks.push(chunk));

    // ❗ Important: listen for errors
    doc.on("error", (err) => {
      console.error("PDF generation error:", err);
    });

    // ✍️ Title
    doc.fontSize(24).font("Helvetica-Bold").text(notes.title, { align: "center" });
    doc.moveDown(1);

    // ✍️ Summary
    doc.fontSize(14).font("Helvetica-Bold").text("Summary", { underline: true });
    doc.moveDown(0.5);
    doc.fontSize(12).font("Helvetica").text(notes.summary);
    doc.moveDown(1.5);

    // ✍️ Sections
    notes.sections.forEach((section: any, index: number) => {
      doc.fontSize(16).font("Helvetica-Bold").text(section.title);
      doc.moveDown(0.5);

      section.content.forEach((point: string) => {
        doc.fontSize(12).font("Helvetica").text(`• ${point}`, { indent: 20 });
        doc.moveDown(0.5);
      });

      if (section.subsections) {
        section.subsections.forEach((subsection: any) => {
          doc.moveDown(0.5);
          doc.fontSize(14).font("Helvetica-Bold").text(subsection.title, { indent: 20 });
          doc.moveDown(0.5);

          subsection.content.forEach((point: string) => {
            doc.fontSize(12).font("Helvetica").text(`• ${point}`, { indent: 40 });
            doc.moveDown(0.5);
          });
        });
      }

      if (index < notes.sections.length - 1) {
        doc.moveDown(1);
      }
    });

    // ✍️ Footer
    doc.fontSize(10).font("Helvetica-Oblique").text("Generated by Notivio", {
      align: "center",
    });

    // ✅ Finalize and get buffer from stream
    doc.end();

    const pdfBuffer = await new Promise<Buffer>((resolve, reject) => {
      doc.on("end", () => resolve(Buffer.concat(chunks)));
      doc.on("error", reject);
    });

    // ✅ Send response as downloadable PDF
    return new NextResponse(pdfBuffer, {
      headers: {
        "Content-Type": "application/pdf",
        "Content-Disposition": `attachment; filename="${notes.title
          .replace(/[^a-z0-9]/gi, "_")
          .toLowerCase()}_notes.pdf"`,
      },
    });
  } catch (error: any) {
    console.error("Error generating PDF:", error);
    return NextResponse.json(
      { error: error.message || "Failed to generate PDF" },
      { status: 500 }
    );
  }
}
